{% extends "base.html" %}

{% block title %}Downloads - You Hoard{% endblock %}

{% block content %}
<div class="page-header">
    <h1 class="page-title">Downloads</h1>
    <p class="page-subtitle">Monitor download progress and queue</p>
</div>

<!-- Queue Stats -->
<div class="stats-grid mb-6">
    <div class="stat-card">
        <div class="stat-value" id="total-downloads">-</div>
        <div class="stat-label">Total Downloads</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="active-downloads">-</div>
        <div class="stat-label">Active</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="queued-downloads">-</div>
        <div class="stat-label">Queued</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="failed-downloads">-</div>
        <div class="stat-label">Failed</div>
    </div>
</div>

<!-- Controls -->
<div class="card mb-6">
    <div class="card-body">
        <div class="download-controls">
            <div class="filter-group">
                <select id="status-filter" class="filter-select">
                    <option value="">All Status</option>
                    <option value="downloading">Downloading</option>
                    <option value="queued">Queued</option>
                    <option value="completed">Completed</option>
                    <option value="failed">Failed</option>
                    <option value="paused">Paused</option>
                </select>
                
                <button id="refresh-downloads" class="btn btn-primary">
                    <span class="refresh-icon">‚ü≥</span> Refresh
                </button>
                
                <button id="clear-completed" class="btn btn-secondary">Clear Completed</button>
            </div>
            
            <div class="auto-refresh">
                <label>
                    <input type="checkbox" id="auto-refresh" checked>
                    Auto-refresh (5s)
                </label>
            </div>
        </div>
    </div>
</div>

<!-- Downloads List -->
<div class="downloads-list" id="downloads-list">
    <div class="loading-placeholder">Loading downloads...</div>
</div>

<style>
.download-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--space-3);
}

.filter-group {
    display: flex;
    gap: var(--space-2);
    align-items: center;
}

.filter-select {
    padding: var(--space-2);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--surface);
    color: var(--text);
    font-size: 0.875rem;
    min-width: 120px;
}

.filter-select:focus {
    outline: none;
    border-color: var(--primary);
}

.refresh-icon {
    display: inline-block;
    transition: transform 0.3s ease;
}

.refresh-icon.spinning {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.auto-refresh label {
    display: flex;
    align-items: center;
    gap: var(--space-1);
    font-size: 0.875rem;
    color: var(--text-secondary);
    cursor: pointer;
}

.auto-refresh input[type="checkbox"] {
    accent-color: var(--primary);
}

.downloads-list {
    display: flex;
    flex-direction: column;
    gap: var(--space-3);
}

.download-item {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    overflow: hidden;
    transition: all 0.2s ease;
}

.download-item:hover {
    border-color: var(--primary);
    box-shadow: var(--glow-primary);
}

.download-header {
    padding: var(--space-3);
    border-bottom: 1px solid var(--border);
}

.download-title {
    font-size: 0.875rem;
    font-weight: 600;
    margin-bottom: var(--space-1);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.download-meta {
    font-size: 0.75rem;
    color: var(--text-secondary);
    display: flex;
    gap: var(--space-3);
}

.download-progress {
    padding: var(--space-3);
    background: var(--surface-hover);
}

.progress-bar-container {
    margin-bottom: var(--space-2);
}

.progress-bar {
    width: 100%;
    height: 8px;
    background: var(--border);
    border-radius: var(--radius-sm);
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--primary), var(--terminal-green));
    border-radius: var(--radius-sm);
    transition: width 0.3s ease;
    min-width: 2px;
}

.progress-fill.error {
    background: var(--error);
}

.progress-fill.paused {
    background: var(--terminal-amber);
}

.progress-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.75rem;
    color: var(--text-secondary);
}

.download-status {
    padding: var(--space-1) var(--space-2);
    border-radius: var(--radius-sm);
    font-size: 0.75rem;
    font-weight: 500;
    text-transform: uppercase;
}

.status-downloading {
    background: rgba(0, 170, 255, 0.2);
    color: #00aaff;
    border: 1px solid rgba(0, 170, 255, 0.3);
}

.status-queued {
    background: rgba(255, 170, 0, 0.2);
    color: var(--terminal-amber);
    border: 1px solid rgba(255, 170, 0, 0.3);
}

.status-completed {
    background: rgba(0, 255, 136, 0.2);
    color: var(--terminal-green);
    border: 1px solid rgba(0, 255, 136, 0.3);
}

.status-failed {
    background: rgba(255, 51, 68, 0.2);
    color: var(--error);
    border: 1px solid rgba(255, 51, 68, 0.3);
}

.status-paused {
    background: rgba(128, 128, 128, 0.2);
    color: #888;
    border: 1px solid rgba(128, 128, 128, 0.3);
}

.download-actions {
    padding: var(--space-3);
    border-top: 1px solid var(--border);
    display: flex;
    gap: var(--space-2);
    justify-content: flex-end;
}

.error-message {
    background: rgba(255, 51, 68, 0.1);
    color: var(--error);
    padding: var(--space-2);
    border-radius: var(--radius-sm);
    font-size: 0.75rem;
    margin-top: var(--space-2);
    border: 1px solid rgba(255, 51, 68, 0.2);
}

.empty-state {
    text-align: center;
    padding: var(--space-8);
    color: var(--text-secondary);
}

.empty-state-icon {
    font-size: 3rem;
    margin-bottom: var(--space-3);
}

@media (max-width: 768px) {
    .download-controls {
        flex-direction: column;
        align-items: stretch;
    }
    
    .download-title {
        flex-direction: column;
        align-items: flex-start;
        gap: var(--space-1);
    }
    
    .download-meta {
        flex-direction: column;
        gap: var(--space-1);
    }
    
    .download-actions {
        justify-content: center;
    }
}
</style>
{% endblock %}

{% block extra_js %}
<script>
class DownloadsPage {
    constructor() {
        this.currentFilter = '';
        this.autoRefreshInterval = null;
        this.refreshRate = 5000; // 5 seconds
        
        this.init();
    }
    
    async init() {
        this.setupEventListeners();
        await this.loadDownloads();
        this.startAutoRefresh();
    }
    
    setupEventListeners() {
        // Status filter
        document.getElementById('status-filter').addEventListener('change', (e) => {
            this.currentFilter = e.target.value;
            this.loadDownloads();
        });
        
        // Refresh button
        const refreshBtn = document.getElementById('refresh-downloads');
        refreshBtn.addEventListener('click', () => {
            this.refreshDownloads();
        });
        
        // Clear completed
        document.getElementById('clear-completed').addEventListener('click', () => {
            this.clearCompleted();
        });
        
        // Auto-refresh toggle
        const autoRefreshCheckbox = document.getElementById('auto-refresh');
        autoRefreshCheckbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                this.startAutoRefresh();
            } else {
                this.stopAutoRefresh();
            }
        });
    }
    
    async loadDownloads() {
        try {
            const params = new URLSearchParams({ limit: 100 });
            
            if (this.currentFilter) {
                params.append('status', this.currentFilter);
            }
            
            const response = await youHoard.apiCall(`/api/downloads?${params}`);
            this.renderDownloads(response.downloads || []);
            this.updateStats(response);
            
        } catch (error) {
            console.error('Failed to load downloads:', error);
            this.renderError('Failed to load downloads');
        }
    }
    
    async refreshDownloads() {
        const refreshIcon = document.querySelector('.refresh-icon');
        refreshIcon.classList.add('spinning');
        
        try {
            await this.loadDownloads();
        } finally {
            setTimeout(() => {
                refreshIcon.classList.remove('spinning');
            }, 500);
        }
    }
    
    renderDownloads(downloads) {
        const container = document.getElementById('downloads-list');
        
        if (downloads.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">üì•</div>
                    <h3>No downloads found</h3>
                    <p>Download queue is empty. <a href="/videos">Go add some videos</a> to get started!</p>
                </div>
            `;
            return;
        }
        
        container.innerHTML = downloads.map(download => this.renderDownloadItem(download)).join('');
    }
    
    renderDownloadItem(download) {
        const progress = Math.round(download.progress || 0);
        const hasProgress = download.status === 'downloading' || download.status === 'completed';
        const hasError = download.status === 'failed' && download.error_message;
        
        return `
            <div class="download-item">
                <div class="download-header">
                    <div class="download-title">
                        <span>${youHoard.escapeHtml(download.video_title)}</span>
                        <span class="download-status status-${download.status}">${download.status}</span>
                    </div>
                    <div class="download-meta">
                        <span>Channel: ${youHoard.escapeHtml(download.channel_name)}</span>
                        <span>Priority: ${download.priority}</span>
                        ${download.started_at ? `<span>Started: ${this.formatTime(download.started_at)}</span>` : ''}
                        ${download.completed_at ? `<span>Completed: ${this.formatTime(download.completed_at)}</span>` : ''}
                    </div>
                </div>
                
                ${hasProgress ? `
                    <div class="download-progress">
                        <div class="progress-bar-container">
                            <div class="progress-bar">
                                <div class="progress-fill ${download.status === 'failed' ? 'error' : download.status === 'paused' ? 'paused' : ''}" 
                                     style="width: ${progress}%"></div>
                            </div>
                        </div>
                        <div class="progress-info">
                            <span>${progress}%</span>
                            <div>
                                ${download.speed ? `<span>${this.formatSpeed(download.speed)}</span>` : ''}
                                ${download.eta ? `<span>ETA: ${this.formatETA(download.eta)}</span>` : ''}
                            </div>
                        </div>
                        ${hasError ? `<div class="error-message">${youHoard.escapeHtml(download.error_message)}</div>` : ''}
                    </div>
                ` : ''}
                
                <div class="download-actions">
                    ${this.renderDownloadActions(download)}
                </div>
            </div>
        `;
    }
    
    renderDownloadActions(download) {
        const actions = [];
        
        switch (download.status) {
            case 'queued':
                actions.push(`<button class="btn btn-danger btn-sm" onclick="downloadsPage.cancelDownload(${download.id})">Cancel</button>`);
                break;
                
            case 'downloading':
                actions.push(`<button class="btn btn-warning btn-sm" onclick="downloadsPage.pauseDownload(${download.id})">Pause</button>`);
                actions.push(`<button class="btn btn-danger btn-sm" onclick="downloadsPage.cancelDownload(${download.id})">Cancel</button>`);
                break;
                
            case 'paused':
                actions.push(`<button class="btn btn-primary btn-sm" onclick="downloadsPage.resumeDownload(${download.id})">Resume</button>`);
                actions.push(`<button class="btn btn-danger btn-sm" onclick="downloadsPage.cancelDownload(${download.id})">Cancel</button>`);
                break;
                
            case 'failed':
                actions.push(`<button class="btn btn-primary btn-sm" onclick="downloadsPage.retryDownload(${download.id})">Retry</button>`);
                actions.push(`<button class="btn btn-danger btn-sm" onclick="downloadsPage.removeDownload(${download.id})">Remove</button>`);
                break;
                
            case 'completed':
                actions.push(`<a href="/videos" class="btn btn-secondary btn-sm">View Video</a>`);
                actions.push(`<button class="btn btn-danger btn-sm" onclick="downloadsPage.removeDownload(${download.id})">Remove</button>`);
                break;
        }
        
        return actions.join('');
    }
    
    updateStats(response) {
        document.getElementById('total-downloads').textContent = response.total || 0;
        document.getElementById('active-downloads').textContent = response.active_count || 0;
        document.getElementById('queued-downloads').textContent = response.queued_count || 0;
        document.getElementById('failed-downloads').textContent = response.failed_count || 0;
    }
    
    startAutoRefresh() {
        this.stopAutoRefresh(); // Clear any existing interval
        
        if (document.getElementById('auto-refresh').checked) {
            this.autoRefreshInterval = setInterval(() => {
                this.loadDownloads();
            }, this.refreshRate);
        }
    }
    
    stopAutoRefresh() {
        if (this.autoRefreshInterval) {
            clearInterval(this.autoRefreshInterval);
            this.autoRefreshInterval = null;
        }
    }
    
    async cancelDownload(downloadId) {
        if (!confirm('Are you sure you want to cancel this download?')) {
            return;
        }
        
        try {
            await youHoard.apiCall(`/api/downloads/${downloadId}/cancel`, { method: 'POST' });
            youHoard.showToast('Download cancelled', 'success');
            this.loadDownloads();
        } catch (error) {
            console.error('Failed to cancel download:', error);
            youHoard.showToast('Failed to cancel download', 'error');
        }
    }
    
    async pauseDownload(downloadId) {
        try {
            await youHoard.apiCall(`/api/downloads/${downloadId}/pause`, { method: 'POST' });
            youHoard.showToast('Download paused', 'success');
            this.loadDownloads();
        } catch (error) {
            console.error('Failed to pause download:', error);
            youHoard.showToast('Failed to pause download', 'error');
        }
    }
    
    async resumeDownload(downloadId) {
        try {
            await youHoard.apiCall(`/api/downloads/${downloadId}/resume`, { method: 'POST' });
            youHoard.showToast('Download resumed', 'success');
            this.loadDownloads();
        } catch (error) {
            console.error('Failed to resume download:', error);
            youHoard.showToast('Failed to resume download', 'error');
        }
    }
    
    async retryDownload(downloadId) {
        try {
            await youHoard.apiCall(`/api/downloads/${downloadId}/retry`, { method: 'POST' });
            youHoard.showToast('Download retrying', 'success');
            this.loadDownloads();
        } catch (error) {
            console.error('Failed to retry download:', error);
            youHoard.showToast('Failed to retry download', 'error');
        }
    }
    
    async removeDownload(downloadId) {
        if (!confirm('Are you sure you want to remove this download from the queue?')) {
            return;
        }
        
        try {
            await youHoard.apiCall(`/api/downloads/${downloadId}`, { method: 'DELETE' });
            youHoard.showToast('Download removed', 'success');
            this.loadDownloads();
        } catch (error) {
            console.error('Failed to remove download:', error);
            youHoard.showToast('Failed to remove download', 'error');
        }
    }
    
    async clearCompleted() {
        if (!confirm('Are you sure you want to remove all completed downloads from the queue?')) {
            return;
        }
        
        try {
            await youHoard.apiCall('/api/downloads/clear-completed', { method: 'POST' });
            youHoard.showToast('Completed downloads cleared', 'success');
            this.loadDownloads();
        } catch (error) {
            console.error('Failed to clear completed downloads:', error);
            youHoard.showToast('Failed to clear completed downloads', 'error');
        }
    }
    
    renderError(message) {
        const container = document.getElementById('downloads-list');
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon" style="color: var(--error);">‚ö†Ô∏è</div>
                <h3>Error Loading Downloads</h3>
                <p>${message}</p>
                <button class="btn btn-primary" onclick="downloadsPage.loadDownloads()">Try Again</button>
            </div>
        `;
    }
    
    formatTime(timestamp) {
        return new Date(timestamp).toLocaleString();
    }
    
    formatSpeed(bytesPerSecond) {
        const units = ['B/s', 'KB/s', 'MB/s', 'GB/s'];
        let speed = bytesPerSecond;
        let unitIndex = 0;
        
        while (speed >= 1024 && unitIndex < units.length - 1) {
            speed /= 1024;
            unitIndex++;
        }
        
        return `${speed.toFixed(1)} ${units[unitIndex]}`;
    }
    
    formatETA(seconds) {
        if (seconds < 60) {
            return `${Math.round(seconds)}s`;
        } else if (seconds < 3600) {
            return `${Math.round(seconds / 60)}m`;
        } else {
            return `${Math.round(seconds / 3600)}h`;
        }
    }
}

// Initialize when page loads
let downloadsPage;
document.addEventListener('DOMContentLoaded', () => {
    downloadsPage = new DownloadsPage();
});

// Clean up auto-refresh when leaving page
window.addEventListener('beforeunload', () => {
    if (downloadsPage) {
        downloadsPage.stopAutoRefresh();
    }
});
</script>
{% endblock %} 